from PIL import Image, ImageDraw
from random import randint
import argparse
import sys
import numpy
from operator import itemgetter
from copy import deepcopy

colors = []


#Represents a point of an image.
class Point:
    def __init__(self, maxX, maxY):
        self.maxSizeX = maxX
        self.maxSizeY = maxY
        self.x = randint(0, maxX)
        self.y = randint(0, maxY)
        self.radius = randint(1, 15)
        self.color = colors[randint(0, (len(colors) - 1))]

    #Mutation of a point based on a probability.
    def mutate(self):
        if randint(1,400) == 1:
            self.color = colors[randint(0, (len(colors) - 1))]

        if randint(1,400) == 2:
            self.radius = randint(1, 15)

        if randint(1,400) == 3:
            self.x = randint(0,self.maxSizeX)
            self.y = randint(0,self.maxSizeY)

#Picure represented by an array of dots.
class Picture:
    def __init__(self, size, numberdots, assignRandom):
        self.size = size
        width, height = size
        if assignRandom == 1:
            self.points = [Point(width, height) for i in range(numberdots)]

    #From the data structure composes an image with the PIL library.
    def composeImage(self):
        newImage = Image.new("RGB", self.size, (255, 255, 255))
        canvas = ImageDraw.Draw(newImage)
        for point in self.points:
            canvas.ellipse(
                [point.x - point.radius, point.y - point.radius, point.x + point.radius, point.y + point.radius],
                outline=point.color, fill=point.color)
        return newImage

    #Compares self to another image passed by parameter, 0 means 0% of difference and 100% 
    #means that the images are the complete oposite.
    #Credits to Josep de Cid who helped on thinking a way to compare two images properly.
    def fitness(self, image2):
        arrayImage1 = numpy.array(self.composeImage(), numpy.int16)
        arrayImage2 = numpy.array(image2, numpy.int16)
        difference = numpy.sum(numpy.abs(arrayImage1 - arrayImage2))
        return (difference / 255.0 * 100) / arrayImage1.size

    #Mutates the points on the image.
    def mutatePic(self):
        for p in self.points:
            p.mutate()

    #Returns all the points datastructure.
    def getPoints(self):
        return self.points

    #Replaces the points on the object for the ones given by parameter.
    def setPoints(self, points):
        self.points = deepcopy(points)

    #Returns the size of the picture
    def getSize(self):
        return self.size

#Represents all the set of pictures the algorithm works with.
class Population:
    def __init__(self, size, numberdots, populationSize, originalImage):
        self.originalImage = originalImage
        self.pictures = [Picture(size, numberdots, 1) for i in range(populationSize)]

    #Does crossover between pics, keeps the top half ones and the others are replaced
    #with the newly generated by crossover and mutation.
    def crossover(self):
        scoredPopulation = self.scorePopulation()
        scoredPopulationSorted = sorted(scoredPopulation, key=itemgetter(1))
        allPics = [a[0] for a in scoredPopulationSorted]
        firstHalf = allPics[:int((len(allPics) + 1) / 2)]
        print(scoredPopulation[0][1])

        for i in range(0, len(firstHalf)):
            newPic = self.mix(firstHalf[i], allPics[randint(0, len(allPics) - 1)])
            newPic.mutatePic()
            firstHalf.append(newPic)

        self.pictures = firstHalf[:len(scoredPopulation)]
        self.best = deepcopy(firstHalf[0])

    #Returns an array of all the picutes ranked based on the fitness function previously defined.
    def scorePopulation(self):
        scoredPopulation = []

        for picture in self.pictures:
            punctuation = picture.fitness(self.originalImage)
            scoredPopulation.append((picture, punctuation))

        return scoredPopulation

    #Returns the best current picture.
    def getBest(self):
        return self.best

    #Creates a child of twoo pictures grabing sets of 5 points of each picture iteratively.
    def mix(self, first, second):
        newPoints = []
        firstPoints = first.getPoints()
        secondPoints = second.getPoints()
        for i in range(len(firstPoints)):
            if i% 10 <= 5:
                newPoints.append(firstPoints[i])
            else:
                newPoints.append(secondPoints[i])
        newPic = Picture(first.getSize(), len(newPoints), 0)
        newPic.setPoints(newPoints)
        return newPic

#Genetic algorithm to compute the image.
def generateImage(imageTarget, generations, numberDots, populationSize):
    generation = 0
    population = Population(imageTarget.size, numberDots, populationSize, imageTarget)

    while (generation != generations):
        print("Generation number: " + str(generation))
        generation += 1
        population.crossover()
        if generation % 50 == 0:
            population.getBest().composeImage().save(".\\generateBrown\\image"+str(generation)+".jpg")
            
    population.getBest().composeImage().save("image"+str(randint(0,1000))+".jpg")

    print("\n")

#Calls the geentic algorithm and extracts the color palette of the image that its going to be replicated.
def pycasso(args):
    try:
        print(args)
        imageTarget = Image.open(args.path)
        # imageTarget.show()
        allColors = imageTarget.getcolors(imageTarget.size[0] * imageTarget.size[1])
        global colors
        colors = [a[1] for a in sorted(allColors, key=itemgetter(1), reverse=True)]
        print('The image will be painted with ' + str(args.numberdots) + ' dots.\n')
        generateImage(imageTarget, args.numbergenerations, args.numberdots, args.populationsize)
    except IOError:
        print("Couldn't open the file")
        exit()

#Accepts severall parameters in order to change manually the number of generations, dots and the size of the population the algorithm works with.
#Any size of image is accepted but the point size should be changed accordingly aswell as the number of dots the algorithm works with.
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--path', default=None, required=True, help='Path to find the image')
    parser.add_argument('--numbergenerations', default=100, type=int, required=False,
                        help='Number of generations the program will make')
    parser.add_argument('--numberdots', default=400, type=int, required=False,
                        help='Number of dots to generate the image')
    parser.add_argument('--populationsize', default=90, type=int, required=False, help='Size of the population')
    args = parser.parse_args()
    pycasso(args)


main()
